// Generated by CoffeeScript 1.6.2
(function() {
  var SETTINGS, animate_moments, create_interval_markers, create_moments, create_spine, layer_moment_tooltips, make_circle, month_num_to_name, parse_date;

  SETTINGS = {
    container: null,
    spine: null,
    start_date: null,
    end_date: null,
    intervals: [],
    no_of_intervals: 0,
    structure: {},
    moments: [],
    pct_buffer_for_markers: 3,
    spine_buffer: 5,
    initial_heights: {
      up: [-10, -22, -28],
      down: [8, 10, 14]
    },
    date_to_marker_index: function(d) {
      return Math.floor((d - this.start_date) / (1000 * 60 * 60 * 24));
    },
    pct_per_interval: function() {
      return (100 - this.pct_buffer_for_markers) / (this.intervals.length - 1);
    },
    date_to_marker_left_pct: function(d) {
      return this.pct_buffer_for_markers + this.pct_per_interval() * (this.date_to_marker_index(parse_date(d)));
    }
  };

  window.create_timeline = function(opt) {
    if (typeof $ === "undefined" || $ === null) {
      $('head').append($('<script/ src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js">'));
    }
    if (!((opt.destination != null) && ((SETTINGS.start_date = parse_date(opt.start_date)) != null) && ((SETTINGS.end_date = parse_date(opt.end_date)) != null))) {
      console.log('You are missing either destination or timeline start/end dates.');
    } else {
      create_interval_markers((SETTINGS.spine = create_spine(opt.destination)));
    }
    if (opt.moments.length !== 0) {
      SETTINGS.structure = opt.structure;
      opt.moments.map(function(m) {
        var _ref;
        return _ref = [parse_date(m.start), parse_date(m.end)], m.start = _ref[0], m.end = _ref[1], _ref;
      });
      SETTINGS.moments = opt.moments.sort(function(a, b) {
        return a.start - b.start;
      });
      return create_moments(SETTINGS.spine);
    }
  };

  create_spine = function(destination) {
    var draw_origin_circle, spine_left;
    draw_origin_circle = function() {
      return make_circle(10, 'black').css('left', 0);
    };
    spine_left = SETTINGS.spine_buffer;
    SETTINGS.container = $('<div/ class="timeline_container">').appendTo(destination);
    return $('<div/ class="spine">').appendTo(SETTINGS.container).css({
      left: spine_left + '%',
      width: 0
    }).animate({
      width: 97 - spine_left + '%'
    }, {
      duration: 400
    }).append(draw_origin_circle().addClass('origin'));
  };

  create_interval_markers = function(spine) {
    var build_label, int_lbl, interval, intervals, left, produce_intervals, set_priority, _i, _len, _ref, _results;
    set_priority = function(interval) {
      if (interval.date === 1) {
        return interval.priority = 3;
      } else if (interval.day === 1) {
        return interval.priority = 2;
      } else {
        return interval.priority = 1;
      }
    };
    produce_intervals = function() {
      var end, interval, start, _i, _len, _ref;
      start = parse_date(SETTINGS.start_date);
      end = parse_date(SETTINGS.end_date);
      while (start <= end) {
        SETTINGS.intervals.push({
          date: start.getDate(),
          day: start.getDay(),
          month: start.getMonth(),
          year: start.getFullYear(),
          js_date: new Date(start.getTime())
        });
        start.setDate(start.getDate() + 1);
      }
      _ref = SETTINGS.intervals;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        interval = _ref[_i];
        set_priority(interval);
      }
      return SETTINGS.intervals;
    };
    build_label = function(interval) {
      return $('<div/ class="interval_label p' + interval.priority + '">').css({
        left: SETTINGS.date_to_marker_left_pct(interval.js_date) + '%'
      });
    };
    _ref = (intervals = produce_intervals());
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      interval = _ref[_i];
      left = SETTINGS.date_to_marker_left_pct(interval.js_date) + '%';
      $('<div/ class="interval_marker p' + interval.priority + '">').css('left', left).delay(800).fadeIn().appendTo(spine);
      int_lbl = build_label(interval);
      switch (interval.priority) {
        case 3:
          int_lbl.text(month_num_to_name(interval.month));
          break;
        case 2:
          int_lbl.text("Mon " + interval.date);
      }
      if (int_lbl.priority !== 1) {
        _results.push(int_lbl.appendTo(spine));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  create_moments = function(spine) {
    var create_moment_tooltips, create_start_end_markers, i, m, _i, _j, _len, _len1, _ref, _ref1;
    create_start_end_markers = function(m) {
      var cols, e_lft, s_lft, _ref;
      _ref = [SETTINGS.date_to_marker_left_pct(m.start) + '%', SETTINGS.date_to_marker_left_pct(m.end) + '%'], s_lft = _ref[0], e_lft = _ref[1];
      cols = ['#47ACCA', '#E0524E'];
      m.start_marker = make_circle(7, cols[0]).addClass('start').css('left', s_lft);
      m.end_marker = make_circle(7, cols[1]).addClass('end').css('left', e_lft).hide();
      return spine.append(m.start_marker, m.end_marker);
    };
    create_moment_tooltips = function(m) {
      var add_moment_functionality, create_info_box, css_values, produce_collapsed_elem, produce_expanded_elem;
      produce_collapsed_elem = function(m, callback) {
        var key, text, _i, _len, _ref;
        text = '';
        _ref = SETTINGS.structure.title;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          text += m[key] + ':';
        }
        console.log(text.slice(0, -1));
        m.collapsed = {};
        m.collapsed.elem = $('<div/ class="info_elem collapsed">').text(text.slice(0, -1));
        return callback(m);
      };
      produce_expanded_elem = function(m) {
        var expanded, i, key, keys, names, text, _i, _j, _len, _len1, _ref;
        expanded = $('<div/ class="info_elem expanded">');
        text = m.collapsed.elem.text() + ' - ';
        _ref = SETTINGS.structure.extendedTitle;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          text += m[key] + ', ';
        }
        m.collapsed.elem.clone().addClass('expanded').text(text.slice(0, -2)).appendTo(expanded);
        text = '';
        names = SETTINGS.structure.content.names;
        keys = SETTINGS.structure.content.keys;
        for (i = _j = 0, _len1 = keys.length; _j < _len1; i = ++_j) {
          key = keys[i];
          if (m[key] != null) {
            $('<a/ class="content_link">').text(names[i]).click(function() {
              return window.location.href = m[links[i]];
            }).appendTo(expanded);
            expanded.html(expanded.html() + ' / ');
          }
        }
        if (expanded.html().slice(-3) === ' / ') {
          expanded.html(expanded.html().slice(0, -3));
        }
        m.expanded = {};
        return m.expanded.elem = expanded;
      };
      css_values = function(elem, info_box) {
        var h, w, _ref;
        info_box.append(elem);
        _ref = [info_box.width(), info_box.height()], w = _ref[0], h = _ref[1];
        elem.hide();
        return {
          w: w,
          h: h
        };
      };
      create_info_box = function(m) {
        var c, e, i, _ref, _ref1;
        m.info_box = $('<div/ class="info_box">').appendTo(SETTINGS.spine);
        _ref = [m.expanded.elem, m.collapsed.elem, m.info_box], e = _ref[0], c = _ref[1], i = _ref[2];
        _ref1 = [css_values(c, i), css_values(e, i)], m.collapsed.css = _ref1[0], m.expanded.css = _ref1[1];
        c.show();
        return i.css({
          width: i.width(),
          height: i.height(),
          marginLeft: -i.width() / 2,
          left: SETTINGS.date_to_marker_left_pct(m.start) + '%'
        }).click(function() {
          m.is_expanded = !m.is_expanded;
          return layer_moment_tooltips();
        });
      };
      add_moment_functionality = function(m) {
        m.bottom = function() {
          return this.goal_top + this.get_projected_css().ih_px;
        };
        m.get_projected_css = function() {
          var c, i, ih, iml, iw, left, leftmost, ml_pct, rightmost, spine_width, width_pct, _ref;
          i = c = m.collapsed;
          if (m.is_expanded) {
            i = m.expanded;
          }
          _ref = [i.css.w, i.css.h, -c.css.w / 2], iw = _ref[0], ih = _ref[1], iml = _ref[2];
          spine_width = parseFloat(SETTINGS.spine.width());
          ml_pct = 100 * iml / spine_width;
          leftmost = ml_pct + (left = SETTINGS.date_to_marker_left_pct(m.start));
          rightmost = leftmost + (width_pct = 100 * iw / spine_width);
          return {
            l: left,
            iml: iml,
            ih_px: ih,
            ilm: leftmost,
            irm: rightmost,
            iw_pct: width_pct,
            iw_px: iw
          };
        };
        m.set_initial_top = function() {
          var css, hs, i, left_index, priority, right_index, top;
          css = m.get_projected_css();
          left_index = Math.floor(((css.ilm - SETTINGS.pct_buffer_for_markers) / SETTINGS.pct_per_interval()) - 1);
          right_index = Math.floor(((css.irm - SETTINGS.pct_buffer_for_markers) / SETTINGS.pct_per_interval()) + 2);
          priority = Math.max.apply(Math, (function() {
            var _i, _len, _ref, _results;
            _ref = SETTINGS.intervals.slice(left_index, +right_index + 1 || 9e9);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              _results.push(i.priority);
            }
            return _results;
          })());
          top = (hs = SETTINGS.initial_heights).down[priority - 1];
          if (this.is_up) {
            top = hs.up[priority - 1] - css.ih_px;
          }
          return m.goal_top = top;
        };
        return m.clash_with = function(m) {
          var h, horizontal, them, us, v, vertical, _ref, _ref1, _ref2;
          vertical = function(us, them) {
            return !((us.t > them.b) || (them.t > us.b));
          };
          horizontal = function(us, them) {
            return !((us.irm < them.ilm) || (them.irm < us.ilm));
          };
          _ref = [this.get_projected_css(), m.get_projected_css()], us = _ref[0], them = _ref[1];
          _ref1 = [this.goal_top, this.bottom(), m.goal_top, m.bottom()], us.t = _ref1[0], us.b = _ref1[1], them.t = _ref1[2], them.b = _ref1[3];
          _ref2 = [vertical(us, them), horizontal(us, them)], v = _ref2[0], h = _ref2[1];
          return v && h;
        };
      };
      produce_collapsed_elem(m, produce_expanded_elem);
      create_info_box(m);
      return add_moment_functionality(m);
    };
    _ref = SETTINGS.moments;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      m = _ref[i];
      create_start_end_markers(m);
      m.is_up = i % 2 === 0;
      create_moment_tooltips(m);
      m.set_initial_top();
    }
    $('.info_box').hide().delay(400).fadeIn();
    _ref1 = SETTINGS.moments;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      m.info_box.css('top', m.goal_top);
    }
    return $('h1').click(function() {
      var cw1, cw4, _k, _len2, _ref2, _results;
      layer_moment_tooltips();
      cw1 = ((function() {
        var _k, _len2, _ref2, _results;
        _ref2 = SETTINGS.moments;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          m = _ref2[_k];
          if (m.id === "1") {
            _results.push(m);
          }
        }
        return _results;
      })())[0];
      cw4 = ((function() {
        var _k, _len2, _ref2, _results;
        _ref2 = SETTINGS.moments;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          m = _ref2[_k];
          if (m.id === "4") {
            _results.push(m);
          }
        }
        return _results;
      })())[0];
      console.log('Does cw1 clash with cw4? ' + cw1.clash_with(cw4));
      _ref2 = SETTINGS.moments;
      _results = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        m = _ref2[_k];
        _results.push(m.info_box.css('top', m.goal_top));
      }
      return _results;
    });
  };

  layer_moment_tooltips = function() {
    var comp, downs, m, ms, place, place_moments, ups, _i, _len, _ref;
    place = function(m, fixed, m_css) {
      var adjust_height, clashed, cm;
      adjust_height = function(m, m_css, cm) {
        if (m.is_up) {
          return m.goal_top = cm.goal_top - m_css.ih_px - 10;
        } else {
          return m.goal_top = cm.bottom() + 10;
        }
      };
      clashed = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = fixed.length; _i < _len; _i++) {
          cm = fixed[_i];
          if (cm.clash_with(m)) {
            _results.push(cm);
          }
        }
        return _results;
      })();
      if (clashed.length !== 0) {
        adjust_height(m, m_css, clashed[0]);
        return place(m, fixed);
      } else {
        return m.fixed = true;
      }
    };
    place_moments = function(moments) {
      var fixed, fm, m, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = moments.length; _i < _len; _i++) {
        m = moments[_i];
        fixed = (function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = moments.length; _j < _len1; _j++) {
            fm = moments[_j];
            if (fm.fixed && m.id !== fm.id) {
              _results1.push(fm);
            }
          }
          return _results1;
        })();
        _results.push(place(m, fixed, m.get_projected_css()));
      }
      return _results;
    };
    ms = SETTINGS.moments.slice(0);
    _ref = [[], []], ups = _ref[0], downs = _ref[1];
    for (_i = 0, _len = ms.length; _i < _len; _i++) {
      m = ms[_i];
      [m.set_initial_top(), m.fixed = false];
      (m.is_up ? ups : downs).push(m);
    }
    comp = function(a, b) {
      if (a.is_expanded === b.is_expanded) {
        return a.start - b.start;
      } else if (a.is_expanded) {
        return 1;
      } else {
        return -1;
      }
    };
    [ups.sort(comp), downs.sort(comp)].map(place_moments);
    return animate_moments();
  };

  animate_moments = function() {
    var c, css, e, i, m, _i, _len, _ref, _ref1, _ref2, _results;
    _ref = SETTINGS.moments;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      _ref1 = [m.expanded.elem, m.collapsed.elem, m.info_box], e = _ref1[0], c = _ref1[1], i = _ref1[2];
      if (!((_ref2 = m.is_expanded) != null ? _ref2 : m.is_expanded = false)) {
        [e.hide(), c.show(), css = m.collapsed.css];
        _results.push(i.animate({
          top: m.goal_top,
          width: css.w,
          height: css.h
        }, {
          duration: 200
        }));
      } else {
        [c.hide(), e.show(), css = m.expanded.css];
        _results.push(i.animate({
          top: m.goal_top,
          width: css.w,
          height: css.h
        }, {
          duration: 200
        }));
      }
    }
    return _results;
  };

  parse_date = function(input) {
    var parts;
    if (input.getDate != null) {
      return new Date(input.getTime());
    }
    parts = input.match(/(\d+)/g);
    return new Date(parts[0], parts[1] - 1, parts[2]);
  };

  month_num_to_name = function(m) {
    return "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Aug,Nov,Dec".split(',')[m];
  };

  make_circle = function(r, c, shadow) {
    var circle, s;
    if (shadow == null) {
      shadow = true;
    }
    s = '0 0 1px black';
    circle = $('<div/ class="circle">').css({
      background: c,
      height: r,
      width: r,
      '-moz-border-radius': r,
      '-webkit-border-radius': r,
      marginTop: -r / 2,
      marginLeft: -r / 2
    });
    if (shadow) {
      circle.css({
        '-webkit-box-shadow': s,
        '-moz-box-shadow': s,
        'box-shadow': s
      });
    }
    return circle;
  };

}).call(this);
